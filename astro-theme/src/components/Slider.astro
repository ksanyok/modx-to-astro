---
import { Image } from 'astro:assets';
import { resolveImage } from '../utils/imageLoader';

interface Props {
  slides: Array<{
    image?: string;
    title?: string;
    text?: string;
    link?: string;
  }>;
}

const { slides = [] } = Astro.props;

const resolvedSlideImages = await Promise.all(
  slides.map(s => resolveImage(s.image || ''))
);
---
{slides.length > 0 && (
  <div class="relative overflow-hidden rounded-xl" data-slider role="region" aria-roledescription="carousel" aria-label="Slider">
    <div class="flex transition-transform duration-500 ease-out" data-slider-track>
      {slides.map((slide, idx) => (
        <div class="min-w-full md:min-w-[33.333%] px-2" role="group" aria-roledescription="slide" aria-label={`Slide ${idx + 1} von ${slides.length}`}>
          <div class="bg-(--color-bg) rounded-xl border border-(--color-border-light) shadow-sm overflow-hidden h-full group card-hover">
            {slide.image && (
              <div class="aspect-video overflow-hidden">
                {resolvedSlideImages[idx] ? (
                  <Image
                    src={resolvedSlideImages[idx]!}
                    alt={slide.title || ''}
                    widths={[360, 720, 1080]}
                    sizes="(max-width: 768px) 100vw, 33vw"
                    loading="lazy"
                    decoding="async"
                    class="w-full h-full object-cover transition-transform duration-600 group-hover:scale-105"
                  />
                ) : (
                  <img
                    src={slide.image}
                    alt={slide.title || ''}
                    loading="lazy"
                    decoding="async"
                    class="w-full h-full object-cover transition-transform duration-600 group-hover:scale-105"
                  />
                )}
              </div>
            )}
            <div class="p-4 sm:p-5 md:p-6">
              {slide.title && <h4 class="text-base sm:text-lg font-semibold mb-2 tracking-tight" set:html={slide.title} />}
              {slide.text && <p class="text-sm text-(--color-text-light) leading-relaxed line-clamp-3" set:html={slide.text} />}
              {slide.link && (
                <a href={slide.link} class="inline-flex items-center gap-1 mt-4 text-(--color-accent) hover:text-(--color-accent-dark) text-sm font-semibold group/link">
                  Mehr erfahren
                  <svg class="w-4 h-4 transition-transform group-hover/link:translate-x-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
                </a>
              )}
            </div>
          </div>
        </div>
      ))}
    </div>
    <button
      data-slider-prev
      class="absolute left-2 sm:left-3 top-1/2 -translate-y-1/2 bg-white/95 backdrop-blur-sm hover:bg-white shadow-lg rounded-full w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center z-10 transition-all duration-200 hover:scale-110 active:scale-95"
      aria-label="Vorheriger Slide"
    >
      <svg class="w-4 h-4 sm:w-5 sm:h-5 text-(--color-text)" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
    </button>
    <button
      data-slider-next
      class="absolute right-2 sm:right-3 top-1/2 -translate-y-1/2 bg-white/95 backdrop-blur-sm hover:bg-white shadow-lg rounded-full w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center z-10 transition-all duration-200 hover:scale-110 active:scale-95"
      aria-label="NÃ¤chster Slide"
    >
      <svg class="w-4 h-4 sm:w-5 sm:h-5 text-(--color-text)" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
    </button>
  </div>
)}

<script>
  document.querySelectorAll('[data-slider]').forEach((slider) => {
    const track = slider.querySelector('[data-slider-track]') as HTMLElement;
    const prev = slider.querySelector('[data-slider-prev]');
    const next = slider.querySelector('[data-slider-next]');
    
    if (!track) return;
    
    let current = 0;
    const totalSlides = track.children.length;

    function getSlideWidth() {
      return window.innerWidth < 768 ? 100 : 33.333;
    }
    function getMaxIndex() {
      return Math.max(0, totalSlides - (window.innerWidth < 768 ? 1 : 3));
    }

    function updateSlider() {
      current = Math.min(current, getMaxIndex());
      track.style.transform = `translateX(-${current * getSlideWidth()}%)`;
    }

    prev?.addEventListener('click', () => {
      current = Math.max(0, current - 1);
      updateSlider();
    });

    next?.addEventListener('click', () => {
      current = Math.min(getMaxIndex(), current + 1);
      updateSlider();
    });

    // Recalculate on resize
    let resizeTimer: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateSlider, 150);
    });

    // Touch swipe support
    let touchStartX = 0;
    let touchStartY = 0;
    let isSwiping = false;

    track.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].clientX;
      touchStartY = e.changedTouches[0].clientY;
      isSwiping = false;
    }, { passive: true });

    track.addEventListener('touchmove', (e) => {
      const dx = Math.abs(e.changedTouches[0].clientX - touchStartX);
      const dy = Math.abs(e.changedTouches[0].clientY - touchStartY);
      if (dx > dy && dx > 10) isSwiping = true;
    }, { passive: true });

    track.addEventListener('touchend', (e) => {
      if (!isSwiping) return;
      const diff = touchStartX - e.changedTouches[0].clientX;
      if (Math.abs(diff) > 50) {
        if (diff > 0) current = Math.min(getMaxIndex(), current + 1);
        else current = Math.max(0, current - 1);
        updateSlider();
      }
    });
  });
</script>
